import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Main class to run Set Covering Problem benchmarks with PSO algorithm
 */
public class Main {
    public static void main(String[] args) {
        // Create and configure parameters
        PSOConfig config = new PSOConfig();
        
        // Create benchmark directory
        File dir = new File(config.benchmarkDir);
        
        if (!dir.exists() || !dir.isDirectory()) {
            System.out.println("Error: Benchmark directory not found. Run SCPDownloader first.");
            return;
        }
        
        // Results summary
        System.out.println("Test Parameters:");
        System.out.println("- Number of runs per benchmark: " + config.numRuns);
        System.out.println("- PSO particles: " + config.numParticles);
        System.out.println("- PSO max iterations: " + config.maxIterations);
        System.out.println("- PSO parameters: w=" + config.w + ", c1=" + config.c1 + ", c2=" + config.c2);
        System.out.println("\nBenchmark,Elements,Subsets,k,AvgCoverage,AvgTime(ms)");
        
        for (String fileName : config.benchmarkFiles) {
            System.out.println("\n=======================================================");
            System.out.println("Testing benchmark file: " + fileName);
            System.out.println("=======================================================");
            
            try {
                // Parse the benchmark file
                SCPInstance instance = parseSCPFile(config.benchmarkDir + File.separator + fileName);
                
                // Calculate k (number of subsets to select) based on config
                int k = instance.m / config.kDivisor;
                if (k < 1) k = 1;
                
                // Print instance information
                System.out.println("Number of rows (elements): " + instance.n);
                System.out.println("Number of columns (subsets): " + instance.m);
                System.out.println("Number of subsets to select (k): " + k);
                
                // Variables for averaging results
                long totalTime = 0;
                int totalCoverage = 0;
                
                // Run multiple times to get average performance
                for (int run = 1; run <= config.numRuns; run++) {
                    System.out.println("\nRun " + run + "/" + config.numRuns);
                    
                    // Create PSO_MCP instance with configuration
                    PSO_MCP pso = new PSO_MCP(instance.subsets, instance.n, config);
                    
                    // Start timer
                    long startTime = System.currentTimeMillis();
                    
                    // Run the PSO algorithm
                    Particle[] result = pso.solution(config.numParticles, k, instance.m);
                    
                    // End timer
                    long endTime = System.currentTimeMillis();
                    long runTime = endTime - startTime;
                    
                    // Get best fitness from the run
                    int bestFitness = 0;
                    for (Particle p : result) {
                        if (p.pBest > bestFitness) {
                            bestFitness = p.pBest;
                        }
                    }
                    
                    // Add to totals
                    totalTime += runTime;
                    totalCoverage += bestFitness;
                    
                    // Output run results
                    System.out.println("Run " + run + " time: " + runTime + " ms, coverage: " + 
                                      bestFitness + "/" + instance.n);
                }
                
                // Calculate and display averages
                double avgTime = totalTime / (double)config.numRuns;
                double avgCoverage = totalCoverage / (double)config.numRuns;
                
                System.out.println("\nAverage Results for " + fileName + ":");
                System.out.println("Average execution time: " + avgTime + " ms");
                System.out.println("Average coverage: " + avgCoverage + "/" + instance.n + 
                                  " (" + (avgCoverage/instance.n*100) + "%)");
                
                // Add to CSV-style summary
                System.out.println(fileName + "," + instance.n + "," + 
                                  instance.m + "," + k + "," + 
                                  avgCoverage + "," + avgTime);
                
            } catch (IOException e) {
                System.out.println("Error processing file " + fileName + ": " + e.getMessage());
            }
        }
    }
    
    /**
     * Parse a Set Covering Problem benchmark file in JSON-like format
     */
    private static SCPInstance parseSCPFile(String filePath) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            // Read the entire file content
            StringBuilder content = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append(" ");
            }
            
            // Parse the content as a list of lists
            String fileContent = content.toString();
            
            // Split the content by "], [" to get individual subset lists
            String[] subsetStrings = fileContent.split("\\],\\s*\\[");
            
            // Clean up the first and last subset strings
            if (subsetStrings.length > 0) {
                subsetStrings[0] = subsetStrings[0].replaceFirst("^\\s*\\[", "");
                int lastIndex = subsetStrings.length - 1;
                subsetStrings[lastIndex] = subsetStrings[lastIndex].replaceFirst("\\]\\s*$", "");
            }
            
            // Count the number of subsets (m)
            int m = subsetStrings.length;
            
            // Find the maximum element number to determine n
            int maxElement = 0;
            List<List<Integer>> parsedSubsets = new ArrayList<>();
            
            for (String subsetString : subsetStrings) {
                List<Integer> subset = new ArrayList<>();
                // Split by commas and parse each number
                String[] elements = subsetString.split(",");
                for (String element : elements) {
                    // Clean and parse the element
                    element = element.trim();
                    if (!element.isEmpty()) {
                        try {
                            int elementNum = Integer.parseInt(element);
                            subset.add(elementNum);
                            if (elementNum > maxElement) {
                                maxElement = elementNum;
                            }
                        } catch (NumberFormatException e) {
                            System.out.println("Warning: Skipping invalid element: " + element);
                        }
                    }
                }
                parsedSubsets.add(subset);
            }
            
            // The number of elements (n) is the maximum element number
            int n = maxElement;
            
            System.out.println("Parsed file with " + n + " elements and " + m + " subsets");
            
            // Create the boolean matrix representation
            boolean[][] subsets = new boolean[m][n];
            
            // Fill the matrix
            for (int i = 0; i < parsedSubsets.size(); i++) {
                List<Integer> subset = parsedSubsets.get(i);
                for (int element : subset) {
                    // Convert to 0-based index
                    if (element > 0 && element <= n) {
                        subsets[i][element - 1] = true;
                    }
                }
            }
            
            return new SCPInstance(n, m, subsets);
        }
    }
    
    /**
     * Class to hold a Set Covering Problem instance
     */
    static class SCPInstance {
        int n;  // Number of elements
        int m;  // Number of subsets
        boolean[][] subsets;
        
        public SCPInstance(int n, int m, boolean[][] subsets) {
            this.n = n;
            this.m = m;
            this.subsets = subsets;
        }
    }
}

/**
 * Configuration class for PSO algorithm and benchmark testing parameters
 */
class PSOConfig {
    // Problem parameters
    String benchmarkDir = "scp_benchmark";  // Changed to a relative path
    String[] benchmarkFiles = {
        "scp41.txt", "scp42.txt", "scp43.txt", "scp44.txt", "scp410.txt",
        "scpa1.txt", "scpa2.txt", "scpa3.txt", "scpa4.txt", "scpa5.txt",
        "scpb1.txt", "scpb2.txt", "scpb3.txt", "scpc1.txt", "scpc2.txt", "scpc3.txt"
    };
    
    // Benchmark test parameters
    int numRuns = 5;         // Number of runs for each benchmark
    int kDivisor = 25;       // k = m / kDivisor (number of subsets to select)
    
    // PSO algorithm parameters
    int numParticles = 30;   // Number of particles
    int maxIterations = 100000; // Maximum iterations for PSO
    double w = 0.729;        // Inertia weight
    double c1 = 1.49445;     // Cognitive coefficient
    double c2 = 1.49445;     // Social coefficient
    double velocityLimit = 4.0; // Maximum velocity magnitude
    
    // Random seed (use -1 for random seed, or specific value for reproducibility)
    long randomSeed = -1;
    
    // Termination criteria
    boolean earlyTermination = true; // Whether to terminate when all elements are covered
    int maxIterationsWithoutImprovement = 10000; // Early stopping if no improvement
}

/**
 * Particle class for PSO algorithm
 */
class Particle {
    boolean[] position; // Selected subsets (true = selected, false = not selected)
    double[] velocity;  // Velocity for each dimension
    int fitness;        // Number of elements covered by current position
    int pBest;          // Best fitness found by this particle
    boolean[] pBestPosition; // Position that gave the best fitness
    
    public Particle(int numSubsets, int k, Random rand) {
        position = new boolean[numSubsets];
        velocity = new double[numSubsets];
        pBestPosition = new boolean[numSubsets];
        
        // Initialize with exactly k random subsets selected
        int selected = 0;
        while (selected < k) {
            int index = rand.nextInt(numSubsets);
            if (!position[index]) {
                position[index] = true;
                selected++;
            }
        }
        
        // Initialize velocities to small random values
        for (int i = 0; i < numSubsets; i++) {
            velocity[i] = rand.nextDouble() * 2 - 1; // Between -1 and 1
        }
        
        // Copy initial position to pBestPosition
        System.arraycopy(position, 0, pBestPosition, 0, numSubsets);
        pBest = 0; // Initialize pBest to 0
    }
    
    // Update position based on velocity using sigmoid function
    public void updatePosition(Random rand, int k, double velocityLimit) {
        boolean[] newPosition = new boolean[position.length];
        
        // First pass: calculate probabilities and make initial selections
        for (int i = 0; i < position.length; i++) {
            double sigmoid = 1.0 / (1.0 + Math.exp(-velocity[i]));
            newPosition[i] = rand.nextDouble() < sigmoid;
        }
        
        // Second pass: enforce exactly k selections
        int selected = 0;
        for (boolean b : newPosition) {
            if (b) selected++;
        }
        
        // If too many subsets are selected, deselect some
        while (selected > k) {
            int index;
            do {
                index = rand.nextInt(position.length);
            } while (!newPosition[index]);
            
            newPosition[index] = false;
            selected--;
        }
        
        // If too few subsets are selected, select more
        while (selected < k) {
            int index;
            do {
                index = rand.nextInt(position.length);
            } while (newPosition[index]);
            
            newPosition[index] = true;
            selected++;
        }
        
        // Update position
        position = newPosition;
    }
}

/**
 * PSO algorithm for Maximum Coverage Problem
 */
class PSO_MCP {
    // Problem-specific data
    private boolean[][] subsets;     // Each subset contains a set of elements
    private int numElements;         // Total number of unique elements
    
    // PSO parameters
    private double w;                // Inertia weight
    private double c1;               // Cognitive coefficient
    private double c2;               // Social coefficient
    private double velocityLimit;    // Maximum velocity magnitude
    private int maxIterations;       // Maximum iterations
    private boolean earlyTermination; // Whether to terminate early
    private int maxIterationsWithoutImprovement; // Early stopping condition
    private Random rand;
    
    public PSO_MCP(boolean[][] subsets, int numElements, PSOConfig config) {
        this.subsets = subsets;
        this.numElements = numElements;
        
        // Set parameters from config
        this.w = config.w;
        this.c1 = config.c1;
        this.c2 = config.c2;
        this.maxIterations = config.maxIterations;
        this.velocityLimit = config.velocityLimit;
        this.earlyTermination = config.earlyTermination;
        this.maxIterationsWithoutImprovement = config.maxIterationsWithoutImprovement;
        
        // Initialize random with seed if provided
        if (config.randomSeed > 0) {
            this.rand = new Random(config.randomSeed);
        } else {
            this.rand = new Random();
        }
    }
    
    // Evaluate fitness: count how many unique elements are covered by selected subsets
    private int evaluateFitness(boolean[] position) {
        boolean[] covered = new boolean[numElements];
        int count = 0;
        
        for (int i = 0; i < position.length; i++) {
            if (position[i]) {
                for (int j = 0; j < numElements; j++) {
                    if (subsets[i][j] && !covered[j]) {
                        covered[j] = true;
                        count++;
                    }
                }
            }
        }
        
        return count;
    }
    
    // Update velocity for a particle
    private void updateVelocity(Particle p, boolean[] gBestPosition) {
        for (int i = 0; i < p.position.length; i++) {
            double r1 = rand.nextDouble();
            double r2 = rand.nextDouble();
            
            // Calculate cognitive and social components
            double cognitive = p.pBestPosition[i] ? 1 : -1;
            double social = gBestPosition[i] ? 1 : -1;
            
            // Update velocity using PSO formula
            p.velocity[i] = w * p.velocity[i] +
                           c1 * r1 * cognitive * (p.position[i] ? -1 : 1) +
                           c2 * r2 * social * (p.position[i] ? -1 : 1);
            
            // Limit velocity to prevent explosion
            if (p.velocity[i] > velocityLimit) p.velocity[i] = velocityLimit;
            if (p.velocity[i] < -velocityLimit) p.velocity[i] = -velocityLimit;
        }
    }
    
    // Main PSO algorithm
    public Particle[] solution(int numParticles, int k, int numSubsets) {
        System.out.println("Starting PSO with " + numParticles + " particles, k=" + k + 
                          ", iterations=" + maxIterations + 
                          ", w=" + w + ", c1=" + c1 + ", c2=" + c2);
        
        // Initialize particles
        Particle[] particles = new Particle[numParticles];
        for (int i = 0; i < numParticles; i++) {
            particles[i] = new Particle(numSubsets, k, rand);
            particles[i].fitness = evaluateFitness(particles[i].position);
            particles[i].pBest = particles[i].fitness;
        }
        
        // Initialize global best
        int gBest = 0;
        boolean[] gBestPosition = new boolean[numSubsets]; // Initialize properly here
        
        // Find initial global best
        for (Particle p : particles) {
            if (p.fitness > gBest) {
                gBest = p.fitness;
                System.arraycopy(p.position, 0, gBestPosition, 0, numSubsets);
            }
        }
        
        // Main PSO loop
        int iterationsWithoutImprovement = 0;
        for (int iter = 0; iter < maxIterations; iter++) {
            boolean improved = false;
            
            for (Particle p : particles) {
                // Update velocity
                updateVelocity(p, gBestPosition);
                
                // Update position (ensuring exactly k subsets are selected)
                p.updatePosition(rand, k, velocityLimit);
                
                // Evaluate new fitness
                p.fitness = evaluateFitness(p.position);
                
                // Update personal best
                if (p.fitness > p.pBest) {
                    p.pBest = p.fitness;
                    System.arraycopy(p.position, 0, p.pBestPosition, 0, numSubsets);
                    
                    // Update global best
                    if (p.fitness > gBest) {
                        gBest = p.fitness;
                        System.arraycopy(p.position, 0, gBestPosition, 0, numSubsets);
                        System.out.println("Iteration " + iter + ": New global best = " + gBest + "/" + numElements);
                        improved = true;
                        
                        // Early termination if we cover all elements
                        if (earlyTermination && gBest == numElements) {
                            System.out.println("Found optimal solution covering all elements! Terminating early.");
                            break;
                        }
                    }
                }
            }
            
            // Early termination checks
            if (earlyTermination && gBest == numElements) {
                break;
            }
            
            // Check if we've gone too long without improvement
            if (improved) {
                iterationsWithoutImprovement = 0;
            } else {
                iterationsWithoutImprovement++;
                
                // Report lack of progress periodically
                if (iterationsWithoutImprovement % 10000 == 0) {
                    System.out.println("Iteration " + iter + ": No improvement for " + 
                                      iterationsWithoutImprovement + " iterations, best = " + 
                                      gBest + "/" + numElements);
                }
                
                // Early stopping if no improvement for too long
                if (iterationsWithoutImprovement >= maxIterationsWithoutImprovement) {
                    System.out.println("No improvement for " + maxIterationsWithoutImprovement + 
                                      " iterations. Terminating early.");
                    break;
                }
            }
        }
        
        printSolution(gBestPosition, gBest);
        return particles;
    }
    
    // Print the solution
    public void printSolution(boolean[] bestPosition, int bestFitness) {
        System.out.println("\nBest solution found:");
        System.out.println("Coverage: " + bestFitness + "/" + numElements + " elements");
        
        System.out.print("Selected subsets: ");
        int selectedCount = 0;
        for (int i = 0; i < bestPosition.length; i++) {
            if (bestPosition[i]) {
                System.out.print((i+1) + " ");
                selectedCount++;
            }
        }
        System.out.println("(" + selectedCount + " subsets)");
        
        // Print which elements are covered
        boolean[] covered = new boolean[numElements];
        for (int i = 0; i < bestPosition.length; i++) {
            if (bestPosition[i]) {
                for (int j = 0; j < numElements; j++) {
                    if (subsets[i][j]) {
                        covered[j] = true;
                    }
                }
            }
        }
        
        int coveredCount = 0;
        for (boolean b : covered) {
            if (b) coveredCount++;
        }
        
        System.out.println("Total elements covered: " + coveredCount + "/" + numElements);
    }
}